vec2 CalcParallaxTexCoord(sampler2D displacementMap, mat3 tbnMatrix, vec3 directionToEye, vec2 texCoords, float scale, float bias)
{
	return texCoords.xy + (directionToEye * tbnMatrix).xy * (texture2D(displacementMap, texCoords.xy).r * scale + bias);
}

float SampleShadowMap(sampler2D shadowMap, vec2 coords, float compare)
{
	return step(compare, texture2D(shadowMap, coords.xy).r);
}

float SampleShadowMapLinear(sampler2D shadowMap, vec2 coords, float compare, vec2 texelSize)
{
	vec2 pixelPosition = coords / texelSize + vec2(0.5);
	vec2 fracPart = fract(pixelPosition);
	vec2 startTexel = (pixelPosition - fracPart) *  texelSize;
	
	float bLTexel = SampleShadowMap(shadowMap, startTexel, compare);
	float bRTexel = SampleShadowMap(shadowMap, startTexel + vec2(texelSize.x, 0.0), compare);
	float tLTexel = SampleShadowMap(shadowMap, startTexel + vec2(0.0, texelSize.y), compare);
	float tRTexel = SampleShadowMap(shadowMap, startTexel + texelSize, compare);
	
	float mixA = mix(bLTexel, tLTexel, fracPart.y);
	float mixB = mix(bRTexel, tRTexel, fracPart.y);
	
	return mix(mixA, mixB, fracPart.x);
}

float SampleShadowMapPCF(sampler2D shadowMap, vec2 coords, float compare, vec2 texelSize)
{
	const float NUM_SAMPLES = 5.0f;
	const float SAMPLES_START = (NUM_SAMPLES - 1.0f) / 2.0f;
	const float NUM_SAMPLES_SQUARED = NUM_SAMPLES * NUM_SAMPLES;

	float result = 0;
	
	for(float y = -SAMPLES_START; y <= SAMPLES_START; y += 1.0f)
	{
		for(float x = -SAMPLES_START; x <= SAMPLES_START; x += 1.0f)
		{
			vec2 coordsOffset = vec2(x, y) * texelSize;
			result += SampleShadowMapLinear(shadowMap, coords + coordsOffset, compare, texelSize);
		}
	}
	
	return result / NUM_SAMPLES_SQUARED;
}